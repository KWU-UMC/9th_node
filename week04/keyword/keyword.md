- ES
    
    Ecma Script는 ‘Javascript의 표준 규격’을 의미한다.
    
    역할: JS의 공통 기반을 보장 → 크로스브라우징·엔진 간 일관성 확보.
    
    버전 표기: ES5, ES6(=ES2015), 이후는 연도 기준(ES2016, ES2017…).
    
- ES6
    - ES6의 주요 변화 및 특징
        - **let/const**: 블록 스코프, 재선언 방지.
        - **Arrow Function**: 간결한 함수, `this` 바인딩 고정.
        - **Class**: 프로토타입 기반 OOP의 문법 설탕.
        - **Template Literals**: 백틱 문자열/보간/멀티라인.
        - **Destructuring**: 구조 분해 할당.
        - **Default/Rest/Spread** 파라미터: 유연한 함수 시그니처.
        - **Promise**: 비동기 제어의 표준화(이후 `async/await`의 토대).
        - **Module(ESM)**: `import/export`로 모듈화.
        - **Map/Set**, **Symbol**, **Iterators/Generators** 등 컬렉션/언어 기능.
    - ES6를 중요시 하는 이유
        - 현대 JS의 **기본 문법**이자, 프레임워크(React/Vue/Node 최신)들이 **ES6+ 전제**.
        - **가독성/유지보수성** 상승, **번들링/트리셰이킹** 최적화 기반.
        - 타입스크립트/바벨/번들러 생태계의 **표준 인터페이스** 역할.
- ES Module
    - **문법**: `import { a } from './a.js'`, `export default fn`.
    - **특징**
        - **정적 구조**(정적 분석 가능) → **트리셰이킹** 유리.
        - **모듈 스코프** 분리, 전역 오염 X.
        - 브라우저 **네이티브 지원**(`type="module"`), Node.js도 공식 지원(`"type": "module"`).
    - **CommonJS(CJS)와 차이**
        - CJS: `require/module.exports`, **런타임 로딩**.
        - ESM: `import/export`, **빌드 타임 분석**.
    - **상호운용 팁**
        - Node: `package.json`에 `"type": "module"` 또는 파일 확장자 `.mjs`.
        - CJS ↔︎ ESM 섞일 때는 **default vs named** 차이, **동적 import(`import()`)** 활용 주의.
- 프로젝트 아키텍처
    - 프로젝트 아키텍처가 중요한 이유
        - 기능 추가 속도, 테스트 용이성, 결합도/응집도, 팀 협업 구조를 **장기적으로 좌우**.
        - 변경 영향 범위를 줄이고, **비즈니스 규칙을 UI/인프라로부터 보호**.
    - Service-Oriented Architecture(Service Layer Pattern)
        - **개념**: **도메인 규칙**을 응집한 **서비스 계층**을 두어 컨트롤러·리포지토리 등과 분리.
        - **장점**: 재사용/테스트 용이, 트랜잭션/권한·검증 로직 집중.
        - **단점**: 과도하면 **Anemic Domain Model**(빈약한 도메인)로 흐르기 쉬움.
        - **언제**: 단일 앱/모놀리식에서 **비즈니스 로직의 중심축**으로 적합.
    - MVC 패턴
        - **Model**(데이터·도메인), **View**(표현), **Controller**(입력/흐름).
        - **장점**: 역할 분리, 전통적 웹 앱에 적합.
        - **단점**: 규모 커질수록 컨트롤러 비대화, **도메인 규칙의 위치**가 모호해지기 쉬움 → 서비스 계층/유스케이스 계층 보완 권장.
    - 그 외 다른 프로젝트 구조
        - **레이어드 아키텍처**: Presentation / Application(Service) / Domain / Infrastructure.
        - **클린 아키텍처**(Hexagonal/Onion): **의존성 역전**으로 도메인 중심, 외부 어댑터로 UI/DB를 플러그인처럼.
        - **모듈러 모놀리식**: 하나의 배포 단위지만, 도메인별 모듈 경계가 명확.
        - **마이크로서비스**: 서비스 단위로 독립 배포/스케일. 조직/운영 성숙도·플랫폼 도구가 충분할 때.
- 비즈니스 로직
    
    제품/도메인의 규칙, 정책, 계산, 검증. “우리 비즈니스가 이렇게 돌아간다”를 코드로 표현.
    
    위치 원칙 :
    
    - UI/컨트롤러에 두지 말 것 (핸들러는 얇게)
    - 서비스/유스케이스/도메인 계층에 응집.
    - 외부 세계(DB, HTTP, 메시지)는 포트/어댑터로 격리.
    
    좋은 형태 :
    
    - 불변 조건과 정책이 한곳에 모여 있고, 입력 검증, 권한, 트랜잭션 경계가 명확.
    - 순수 함수/풍부한 도메인 모델(불변 객체, 명시적 메서드) 선호.
- DTO (Data Transfer Object)
    
    계층/서비스 경계 간 데이터 전달용 평면 객체(필드만, 로직 없음).
    
    쓰는 이유:
    
    - API 스펙 안정화(내부 모델 변경이 외부 계약에 영향 주지 않도록).
    - 검증/직렬화 전담
    - 과다 노출 방지
    
    장점 : 보안,버전관리, 유지보수에 유리, 테스트 쉬움.
    
    단점 : 변환 매핑 비용 증가(매퍼 필요 - 수동/자동)